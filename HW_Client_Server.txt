HW
Client_Server
1) Прочиать про клиент-серверную архитектуру

Клиент-серверная архитектура – сборное понятие, состоящее из двух взаимодополняющих компонентов: сервера и клиента.

Клиент – локальный компьютер на стороне виртуального пользователя, который выполняет отправку запроса к серверу для возможности 
предоставления данных или выполнения определенной группы системных действий.

Сервер – очень мощный компьютер или специальное системное оборудование, которое предназначается для разрешения 
определенного круга задач по процессу выполнения программных кодов. Он выполняет работы сервисного обслуживания п
о клиентским запросам, предоставляет пользователям доступ к определенным системным ресурсам, сохраняет данные или БД.

2) Что такое HTTP и HTTPS
HTTP, или Hyper Text Transfer Protocol, — это протокол передачи гипертекстовой разметки, которая используется для передачи данных в интернете

HTTPS — это не совсем протокол. Это расширение HTTP-протокола — объединение двух протоколов: HTTP и SSL или HTTP и TLS. 

Протоколы TLS (Transport Layer Security) и SSL (Secure Socket Layer) — криптографические. Это значит, что они позволяют шифровать данные, которые
 передаются между браузером и сервером. Расшифровать эти данные могут только сервер и браузер, для всех остальных это будет набор нечитаемых 
символов.

У ресурса/сайта, поддерживающего HTTPS, есть SSL/TLS-сертификат, который выдается центром сертификации. 
Если у ресурса в адресной строке есть зеленый замок, соединение с ним защищено.

HTTP — универсальный протокол. Он может передавать любые данные: страницы, музыку, видео, PDF-файлы. 
Но его минус в том, что он открытый: данные, которые передает протокол, никак не защищены. 

По пути между браузером и сервером его легко перехватить, прочитать данные, например, пароли или данные кредитной карты. 
Все равно, что отправлять посылки и письма по почте без конвертов. Кроме того, HTTP-ответ можно подменить или добавить в него свои данные. 

HTTPS тоже можно перехватить, но толку от этого мало — данные зашифрованы, а секретного ключа для расшифровки нет. 
HTTPS шифрует данные. 

3) HTTP методы
HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, 
что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. 

GET
Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
HEAD
HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.
POST
POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
PUT
PUT заменяет все текущие представления ресурса данными запроса.
DELETE
DELETE удаляет указанный ресурс.
CONNECT
CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.
OPTIONS
OPTIONS используется для описания параметров соединения с ресурсом.
TRACE
TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.
PATCH
PATCH используется для частичного изменения ресурса.

4) HTTP статус коды сервера

Во время запроса информации браузером или поисковым роботом ему отдается определенный HTTP код состояния сервера. 
Коды состояния HTTP протокола состоят из трех цифр от 100 и до 526. Диапазон значений кодов сервера постоянно расширяется
 и вводятся новые значения.

Существуют основные группы ответов сервера:

Информационные (100 — 105)
Успешные (200 — 226)
Перенаправление (300 — 307)
Ошибка клиента (400 — 499)
Ошибка сервера (500 — 526)
Основные и часто встречающие типы ответов сервера это: 200, 404, 500 и 301

5) Что такое ядро браузера 

Браузер = оболочка + ядро
Среди них относительно больше типов оболочек и меньше ядер. Оболочка относится к оболочке браузера: например, меню, панели инструментов и т. Д. Он в основном предназначен для работы с пользовательским интерфейсом, настройки параметров и так далее. Он вызывает ядро ​​для реализации различных функций. Ядро - это ядро ​​браузера. 
Ядро - это программа или модуль, который отображает контент на основе языка разметки.

Браузерный движок выполняет всю "грязную" работу: загрузка, обработка, отрисовка данных и все возможные расчёты.

6) Какие браузеры какие ядра используют
	
Движки браузеров

-Браузеры на движке WebKit
Движок с открытым кодом, который разрабатывается Apple Computer.
Safari
Konqueror

-Браузеры на движке Blink
Создан на основе WebKit, Blink используется для браузера Chromium и как следствие для его производных.
Chromium
Google Chrome
Яндекс.Браузер
Opera
Vivaldi
Microsoft Edge

-Браузеры на движке Gecko
Движок с открытым кодом Gecko разработан Mozilla Foundation.
Mozilla Firefox
SeaMonkey
Avant Browser
K-Meleon
Netscape Browser (использует как Gecko, так и Trident)

-Браузеры на движках KHTML
Движок с открытым кодом, разработанный в рамках KDE, послужил основой для WebKit.
Konqueror
ABrowse

-Браузеры на движке Trident
Microsoft переходит на Blink.
Trident разработан Microsoft для Internet Explorer.
Internet Explorer
Maxthon (прежде известный как MyIE2)
Slim Browser
GreenBrowser

-Браузер на движке Presto - более не используется
Opera перешла на движок Blink.
Движок Opera (Presto) лицензирован Adobe и интегрирован в пакет Adobe Creative Suite.
Opera

7) Что такое API

API (МФА [ˌeɪ.piˈaɪ]; аббр. от англ. Application Programming Interface — «программный интерфейс приложения»[1]) — описание способов 
(набор классов, процедур, функций, структур или констант), 
которыми одна компьютерная программа может взаимодействовать с другой программой.

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».

Если переводить на русский, это было бы слово «договор». Договор между двумя сторонами, как договор на покупку машины:

мои обязанности — внести такую то сумму,
обязанность продавца — дать машину.

8. Что такое ендпоинты
Ендпоинт (англ. Endpoint) - это, по-факту, уникальная для вашего сервера комбинация URI i HTTP метода 
(GET http://localhost:3000/weather, POST http://localhost:3000/posts и т.д.), 
которой соответствует определенная логика обработки запроса клиента.

Если говорить про веб, а чаще всего этот термин юзается в веб, то
На mysite.com может висеть ваше приложение
И у него могут быть ендпоинты
mysite.com/healthcheck
mysite.com/action.php

Встречаются немного различные интерпретации этого понятия. Например такая. Каждый api-сервис имеет endpoint, 
к которому и нужно обращаться, например отправлять http-запрос. Обычно это url. 
Т.о. endpoint - это url. Или такая. url включает в себя маршрут (основная часть адреса сервиса) и endpoint 
(часть url, которая содержит например имя вызываемого метода). Существует один маршрут и у него несколько эндпоинтов. 
Т.о. здесь endpoint - это только часть url.

9) URL (URI, URL, URN)
URI (Uniform Resource Identifier) – это строка символов, которая используется для идентификации 
какого-либо ресурса по его адресу или по его имени, либо по тому и тому вместе.

Чтобы стало понятнее проведем аналогию с реальным миром на примере какого-нибудь человека. У человека есть имя, например Боб. 
Также у человека есть адрес проживания, например, пр. Победы 152. Предположим, нам нужно найти человека. 
Мы можем это сделать, начав поиск только по имени, или только по адресу, или по имени и адресу вместе.

URL (Uniform Resource Locator) – это строка символов, которая используется для идентификации какого-либо ресурса, 
но только по его адресу, по его местоположению.

URN (Uniform Resource Name) – это строка символов, которая используется для идентификации какого-либо ресурса, но только по его имени.
Мы знаем этого человека, знаем, что его зовут Боб. Но мы не знаем, где он живет. Нам придется искать его только по имени.

Потому что URI может использовать и адрес, и имя при идентификации ресурса. В то время как URL и URN только адрес и только имя соответственно.

URL чаще всего используется в Интернете для поиска ресурсов на сервере. URL буквально точно показывает нам, как определить ресурс, именно по его адресу. 
Если ввести подобный URL в строке поиска браузера, то будет осуществлен поиск соответствующего ресурса. 

Любой URL состоит из нескольких компонентов. Протокол и хост являются обязательными, все остальные - нет.
На текущий день URN все еще считается экспериментальным и не так сильно распространен, как URL, 
так как для полной поддержки URN требуется поддерживающая его развитая сетевая инфраструктура.

Подводя итог можно сказать, что если мы говорим про сеть Интернет, то чаще всего используем термин URL, 
так как находим определенный ресурс в сети именно по его адресу на каком-то сервере. 
Также часто можно встретить аббревиатуру URI, подразумевающую именно URL. 
Хотя по факту это не совсем так, потому что URL является часть URI. В то же время в контексте веба URN практически не используется.

10) Идемпотентные HTTP методы

Идемпотентность помогает проектировать более надёжные системы. Это математическая концепция, которую должен понимать каждый разработчик. 
Операция считается идемпотентной, если её многократное выполнение приводит к тому же результату, что и однократное выполнение. 
Например, умножение на 1 — идемпотентная операция.

HTTP-методы могут быть идемпотентными или нет.

DELETE — идемпотентный метод. Вы можете сколько угодно раз использовать DELETE, но результат будет всегда таким же, как после первого выполнения операции. Например, DELETE /users/4/contacts/3 удаляет контакт с ID 3. Если вы выполните эту же операцию ещё раз, ничего не произойдёт, так как контакт уже удалён.

GET — тоже идемпотентный метод. Это даже не просто идемпотентный, но ещё и безопасный метод. А безопасные методы можно сравнить с умножением на единицу. Умножать на 1 можно сколько угодно раз, результат всегда будет одинаковым. GET просто получает ресурс. Например, никогда не стоит использовать нормальные ссылки для удаления ресурсов.

POST не относится к идемпотентным методам. При каждом выполнении POST можно ждать побочных эффектов. Например, когда вы используете POST для отправки данных из контактной формы, отправляется письмо.

Потребители и провайдеры используют эту концепцию, когда речь идёт об API. 


11) Безопасные HTTP методы

 Каждый HTTP запрос должен содержать метод. HTTP методы запроса делятся на идемпотентные и безопасные методы. 

HTTP стандарт четко говорит о том, что программа, которая работает с сетью интернет, представляет пользователя, 
поэтому она должна информировать пользователя о любых действиях, которые происходят и которые он может произвести, 
но которые могут иметь непредсказуемые значения для самого пользователя или для других лиц. 
Другими словами: ваш браузер должен информировать вас о любых действия во время HTTP соединения. 

На данный момент принято соглашение о том, что HTTP методы GET и HEAD никогда не должны иметь иного значения, 
кроме загрузки, поэтому данные HTTP методы нужно рассматривать, как безопасные, это требование HTTP. 
Поэтому ваш браузер, когда используются методы POST, PUT или DELETE предупреждает вас о том, 
что может произойти потенциально опасное действие и спрашивает: нужно ли его выполнить.


Номер	HTTP метод и его описание
1	HTTP метод GET
Метода GET в HTTP используется для получения информации от сервера по заданному URI (URI в HTTP). 
Запросы клиентов, использующие метод GET должны получать только данные и не должны никак влиять на эти данные.
2	HTTP метод HEAD
HTTP метод HEAD работает точно так же, как GET, но в ответ сервер посылает только заголовки и статусную строку без тела HTTP сообщения.
3	HTTP метод POST
HTTP метод POST используется для отправки данных на сервер, например, из HTML форм, которые заполняет посетитель сайта.
4	HTTP метод PUT
HTTP метод PUT используется для загрузки содержимого запроса на указанный в этом же запросе URI.
5	HTTP метод DELETE 
HTTP метод DELETE удаляет указанный в URI ресурс.
6	HTTP метод CONNECT
HTTP метод CONNECT преобразует существующее соединение в тоннель.
7	HTTP метод OPTIONS
HTTP метод OPTIONS используется для получения параметров текущего HTTP соединения.
8	HTTP метод TRACE
HTTP метод TRACE создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи.

12) Идентфикация, Аутентификация, Авторизация

За этими сложными терминами скрываются действия, выполняемые ежедневно большинством пользователей машинально. 
При входе в онлайн банкинг или электронную почту система безопасности сайта просит ввести учетные данные: логин и пароль (или отпечаток пальца). 
В обмен на верную пару логин-пароль Вы получаете доступ к своим финансам или электронной почте.
На самом деле никакого обмена не происходило. Произошли поочередно три процесса: идентификация, аутентификация и авторизация.

Идентификация — процесс распознавания пользователя по его идентификатору.
Аутентификация — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает.
Авторизация — предоставление определённых прав.

Находясь на сайте банка, пользователь решает зайти в личный кабинет, чтобы сделать денежный перевод. 
На странице личного кабинета система вначале просит ввести идентификатор. 
Это может быть логин, имя и фамилия, адрес электронной почты или номер мобильного телефона.
Какой конкретно вид данных необходимо ввести – зависит от ресурса. 
Данные, которые указывались при регистрации, необходимо ввести для получения доступа. 
Если при регистрации указывалось несколько типов данных – и логин, и адрес электронной почты, и номер мобильного, то система сама 
подскажет что ей конкретно нужно.
Ввод этих данных необходим для идентификации человека за монитором как пользователя конкретно этого банка.
Если пользователь в качестве идентификатора ввел «Александр Петров», и система нашла в своей базе запись о пользователе с таким именем, 
то идентификация завершилась.
После идентификации следует процесс аутентификации, в котором пользователю нужно доказать, что он является человеком, 
который регистрировался под именем Александр Петров.
Для доказательства необходимо наличие одного из типов аутентификационных данных:
Нечто, присущее только пользователю. Биометрические данные: сканеры лица, отпечатки пальцев или сетчатки глаза.
Нечто, известное только пользователю. Сюда относятся pin-коды, пароли, графические ключи, секретные слова.
Нечто, имеющееся у пользователя. В данном качестве может выступать токен, то есть компактное устройство, 
предназначенное для обеспечения информационной безопасности пользователя, также используется для идентификации владельца. 
Самые простые токены не требуют физического подключения к компьютеру – у них имеется дисплей, где отображается число, которое пользователь вводит в систему для осуществления входа; более сложные подключаются к компьютерам посредством USB и Bluetooth-интерфейсов.
Самый распространенный тип аутентификационных данных – это пароль. Именно поэтому так важно создавать и правильно хранить свои пароли.

После ввода пользователем пароля система проверяет: соответствует ли условный пароль «Q45fp02@13» пользователю с именем Александр Петров. Таким образом происходит аутентификация.
Если все верно, и пара логин-пароль верны, то система предоставит пользователю доступ к его ресурсам и совершение банковских операций, то есть произойдет авторизация.
Описанные процессы всегда происходят только в таком порядке: идентификация, аутентификация, авторизация. Вся цепочка потеряет смысл, если, например, сайт сначала предоставит доступ к денежным средствам пользователя, а потом будет уточнять, он ли это на самом деле.
Процессы идентификации, аутентификации и авторизации характерны не только для онлайн-банкинга, но и для электронной почты, социальных сетей и других ресурсов.
В реальной жизни мы также сталкиваемся идентификацией, аутентификацией и авторизацией. Примером может служить проверка документов сотрудником полиции. Вы представились как Александр Петров, и сотрудник полиции идентифицировал Вас как Александра Петрова. Для аутентификации необходим паспорт, в котором видно, что Александр Петров выглядит так же, как и вы. Авторизацией в данном случае будет то, что сотрудник отпустит вас и пожелает счастливого пути, т.е. предоставит право свободного перемещения.
Процессы идентификации, аутентификации и авторизации есть во многих сферах. Даже в простейших детских сказках. Сказка «Волк и семеро козлят» является идеальным примером для демонстрации.
Здесь козлята выступают в роли системы безопасности, идентифицируя каждого, кто подходит к двери. В качестве данных для аутентификации выступает биометрия – тонкий голосок мамы-козы. И если в первый раз волк не смог пройти аутентификацию (его выдал грубый голос), то со второй попытки (после того как ему перековали горло, и он запел тонким голоском) он аутентифицировался как мама-коза и козлята «авторизовали» его в свою избу.
Несмотря на то, что сказка закончилась благополучно, доступ к козлятам был получен неправомерно. Волку удалось обмануть процессы идентификации и аутентификации и тем самым пройти авторизацию.
Если в старой детской сказке это оказалось возможным, то что говорить о современных злоумышленниках. Чтобы защитить свои денежные средства и персональные данные и козлят от волка от злоумышленника необходимо использовать более сложные способы аутентификации. 


13) Что такое IP

IP-адрес — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP
IP-адрес представляет собой серию из 32 двоичных бит (единиц и нулей). 
Так как человек невосприимчив к большому однородному ряду чисел, такому как этот 11100010101000100010101110011110 
(здесь, к слову, 32 бита информации, так как 32 числа в двоичной системе), было решено разделить ряд на четыре 8-битных байта и 
получилась следующая последовательность: 11100010.10100010.00101011.10011110. 
Это не сильно облегчило жизнь и было решение перевести данную последовательность в, привычную нам, 
последовательность из четырёх чисел в десятичной системе, то есть 226.162.43.158. 4 разряда также называются октетами. 
Данный IP адрес определяется протоколом IPv4. 
По такой схеме адресации можно создать более 4 миллиардов IP-адресов.

IP-адреса делятся на 5 классов (A, B, C, D, E). A, B и C — это классы коммерческой адресации. D – для многоадресных рассылок, 
а класс E – для экспериментов.

Класс А: 1.0.0.0 — 126.0.0.0, маска 255.0.0.0
Класс В: 128.0.0.0 — 191.255.0.0, маска 255.255.0.0
Класс С: 192.0.0.0 — 223.255.255.0, маска 255.255.255.0
Класс D: 224.0.0.0 — 239.255.255.255, маска 255.255.255.255
Класс Е: 240.0.0.0 — 247.255.255.255, маска 255.255.255.255

Теперь о «цвете» IP. IP бывают белые и серые (или публичные и частные). Публичным IP адресом называется IP адрес, 
который используется для выхода в Интернет. 
Адреса, используемые в локальных сетях, относят к частным. Частные IP не маршрутизируются в Интернете.

14) Что такое октеты в DNS

Любой сайт в интернете фактически находится на каком-либо устройстве. Отдельный компьютер, подключенный к интернету, имеет индивидуальный номер,
 который называется IP-адресом. Он представляет собой набор из четырех чисел от 0 до 255. Благодаря этому адресу можно узнать, откуда загружается 
страница нужного нам ресурса.

IP-адрес устройства можно сравнить с номером мобильного телефона, а DNS — с телефонной книгой. 
Если говорить конкретнее, DNS — система доменных имен, которая обеспечивает связь между наименованием сайта и его цифровым адресом.

Иными словами, пользователь набирает доменное имя ресурса в адресной строке браузера, а DNS конвертирует его в IP-адрес и 
передает вашему устройству. После чего компьютер, находящийся по этому адресу, обрабатывает запрос и присылает информацию для открытия 
необходимой страницы сайта.

Структура пакета DNS

    +---------------------+
    |        Header       | Header — Заголовок DNS пакета, состоящий из 12 октет.
    +---------------------+
    |       Question      | Секция запросов
    +---------------------+
    |        Answer       | Секция ответа
    +---------------------+
    |      Authority      | Секция ответа об уполномоченных серверах
    +---------------------+
    |      Additional     | Секция ответа дополнительных записей

Question section — в этой секции DNS-клиент передает запросы DNS-серверу сообщая о том, для какого имени необходимо разрешить (зарезолвить) запись DNS, а также какого типа (NS, A, TXT и т.д.). Сервер при ответе, копирует эту информацию и отдает клиенту обратно в этой же секции.

Answer section — сервер сообщает клиенту ответ или несколько ответов на запрос, в котором сообщает вышеуказанные данные.

Authoritative Section — содержит сведения о том, с помощью каких авторитетных серверов было получена информация включенная в секцию DNS-ответа.

Additional Record Section — дополнительные записи, которые относятся к запросу, но не являются строго ответами на вопрос.

Записей в секциях может быть как несколько, так и не быть вообще. Всё определяется заголовком.

                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      ID                       |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    QDCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ANCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    NSCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ARCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
ID (16 бит) — данное поле используется как уникальный идентификатор транзакции. Указывает на то, что пакет принадлежит одной и той же сессии “запросов-ответов” и занимает 16 бит.

QR (1 бит) — данный бит служит для индентификации того, является ли пакет запросом (QR = 0) или ответом (QR = 1).

Opcode (4 бита) — с помощью данного кода клиент может указать тип запроса, где обычное значение:

0 — стандартный запрос,
1 — инверсный запрос,
2 — запрос статуса сервера.
3-15 – зарезервированы на будущее.

AA (1 бит) — данное поле имеет смысл только в DNS-ответах от сервера и сообщает о том, является ли ответ авторитетным либо нет.

TC (1 бит) — данный флаг устанавливается в пакете ответе в том случае если сервер не смог поместить всю необходимую информацию в пакет из-за существующих ограничений.

RD (1 бит) — этот однобитовый флаг устанавливается в запросе и копируется в ответ. Если он флаг устанавливается в запросе — это значит, что клиент просит сервер не сообщать ему промежуточных ответов, а вернуть только IP-адрес.

RA (1 бит) — отправляется только в ответах, и сообщает о том, что сервер поддерживает рекурсию

Z (3 бита) — являются зарезервированными и всегда равны нулю.

RCODE (4 бита) — это поле служит для уведомления клиентов о том, успешно ли выполнен запрос или с ошибкой.

0 — значит запрос прошел без ошибок;
1 — ошибка связана с тем, что сервер не смог понять форму запроса;
2 — эта ошибка с некорректной работой сервера имен;
3 — имя, которое разрешает клиент не существует в данном домене;
4 — сервер не может выполнить запрос данного типа;
5 — этот код означает, что сервер не может удовлетворить запроса клиента в силу административных ограничений безопасности.

QDCOUNT(16 бит) – количество записей в секции запросов
ANCOUNT(16 бит) – количество записей в секции ответы
NSCOUNT(16 бит) – количество записей в Authority Section
ARCOUNT(16 бит) – количество записей в Additional Record Section


Окте́т в информатике — восемь двоичных разрядов (8 бит). В русском языке октет обычно называют байтом. 
Октет может принимать 256 возможных состояний (кодов, значений, комбинаций битов (нулей и единиц)).


15) Что такое порт, сколько портов у Linux сервера

Порт (англ. port) — целое неотрицательное число, записываемое в заголовках протоколов транспортного уровня сетевой модели OSI (TCP, UDP, SCTP, DCCP).

linux порты — это специальные процессы, которые обслуживают сетевые соединения на заданном адресе. После того, как ваш компьютер подключается к интернету ему назначается уникальный ip-адрес, по которому его можно идентифицировать. Если на вашем компьютере открыты специальные порты, то программы использующие их смогут обмениваться информацией между собой. Но если ваш компьютер не защищен, то любая программа сможет открыть необходимый ей порт и с помощью него передавать конфиденциальную информацию на чужой компьютер.

Поэтому очень важно знать, какие именно порты в linux открыты на вашем компьютере.

Для операционной системы Linux существуют 3 разных типа сетевых портов:

Хорошо известные порты (0-1023) – зарезервированы для операционной системы и основных сервисов.
Зарегистрированные порты (1024-49151) – которые могут использоваться приложениями, конкретными службами и пользователями.
Динамические и / или частные порты (49152-65535)

Сетевой порт идентифицируется его номером, соответствующим IP-адресом и типом протокола связи, таким как TCP или UDP.

Порт прослушивания - это сетевой порт, который прослушивает приложение или процесс, выступая в качестве конечной точки связи.

Каждый порт прослушивания может быть открыт или закрыт (отфильтрован) с помощью брандмауэра. В общих чертах, открытый порт - это сетевой порт, 
который принимает входящие пакеты из удаленных мест.

Вы не можете иметь две службы, прослушивающие один и тот же порт на одном и том же IP-адресе.

Например, если вы используете веб-сервер Apache, который прослушивает порты, 80 и 443 вы пытаетесь установить Nginx, 
позднее не удастся запустить, потому что порты HTTP и HTTPS уже используются.

netstat — это консольная утилита позволяющая просмотреть сетевые соединения, таблицы маршрутизации и другие параметры сетевых интерфейсов.

Ключи:
-a	выводит список всех портов
-l	показывает только прослушиваемые порты
-p	показывает имя программы и ее PID
-t	показывает tcp порты
-u	показывает udp порты
-n	показывает ip адреса в числовом виде
-s	выводит статистику по всем открытым портам
Пример использования:
netstat -a

Виды состояния:

ESTABLISHED — соединение установлено
SYN_SENT — сокет пытается установить соединение
SYN_RECV — начальная синхронизация соединения
FIN_WAIT1 — сокет закрыт, ожидание отключения соединения
FIN_WAIT2 — ожидание отключения удаленной стороны
TIME_WAIT — ожидание после закрытия повторной передачи отключения удаленной стороны
CLOSED — соединение закрыто, сокет не используется
CLOSE_WAIT — удаленный узел отключился, сокет скоро будет закрыт
LAST_ACK — сначала отключилась удаленная сторона, а затем сокет будет закрыт
LISTEN — сокет ожидает входящих соединений
CLOSING — закрытие сокета, точнее сокет закрыт, а затем отключился удаленный узел
UNKNOWN — состояние сокета неизвестно.

16) Уровни OSI

Протоколы обмена (или просто протоколы) необходимы, чтобы участники обмена информацией понимали друг друга. 
В работе компьютерных сетей задействуется множество протоколов, относящихся к разным сетевым уровням. 
Например, сетевая карта компьютера следует протоколу, который описывает перевод цифровых данных в передающийся по проводам аналоговый сигнал; 
браузер связывается с сайтом в Интернете при помощи транспортного протокола TCP; сервер и браузер общаются, используя протокол HTTP.

Иными словами, протокол — это набор соглашений между разработчиками ПО и аппаратуры. Текст протокола отвечает на вопрос: 
“Что нужно сделать, чтобы программы и устройства могли взаимодействовать с другими программами/устройствами, поддерживающими протокол”. 

OSI - это аббревиатура от Open Systems Interconnection, что в переводе буквально означает “Взаимодействие открытых систем”. Речь не идет об Open Source, открытые системы в данном случае являются системами, построенными на основе открытых (общедоступных) спецификаций, соответствующих стандартам. 

Часто можно встретить термин “эталонная модель OSI”. Эталонная модель описывает, какие уровни должны быть в сети и какие функции выполняются на каждом из уровней. OSI модель разделяет все протоколы на 7 таких уровней:

Физический (Physical)
Канальный (Datalink)
Сетевой (Network)
Транспортный (Transport)
Сеансовый (Session)
Представительный (Presentation)
Прикладной (Application)

Физический уровень
Все уровни нумеруют, начиная с самого близкого к среде передачи данных. В данном случае первым будет физический уровень модели osi. Здесь происходит преобразование битов информации в сигналы, которые затем передаются по среде. Используемый физический протокол зависит от того, каким образом компьютер подключен к сети. 

Например, в случае обычной локальной сети на основе витой пары применяется спецификация 100BASE-TX (стандарт IEEE 802.3u), определяющая кабели и разъемы для соединения, технические характеристики проводов, частоты, напряжение, кодировку и многое другое. Подключения через Wi-Fi сложнее, так как данные передаются по радиоканалам, а эфир один на всех. Взаимодействие Wi-Fi устройств описывается спецификацией IEEE 802.11, которая, как и Ethernet, включает помимо физического уровня часть канального. 

При выходе в Интернет через сеть сотовой телефонной связи используются спецификации GSM, включающие специальные протоколы (например GPRS) и затрагивающие не только два первых, но и сетевой уровень. Бывают и относительно простые протоколы, например RS232. Он будет использоваться, если соединить два компьютера нуль-модемным кабелем через COM-порты.

#Канальный уровень

Далее располагается канальный уровень модели osi. На этом слое пересылаются не биты, а целые сообщения (кадры, фреймы). Канальный уровень получает с физического поток бит, находит начало и конец сообщения и упаковывает биты в кадр. Также происходит обнаружение и коррекция ошибок. В многоточечных сетевых соединениях, где один и тот же канал связи используется разными компьютерами, канальный уровень дополнительно обеспечивает физическую адресацию и управление доступом к разделяемой среде передачи данных. 

Часть задач, которые в теории решают протоколы этого уровня, решена в спецификациях Ethernet и Wi-Fi, но есть кое-что еще. Сетевые интерфейсы в многоточечном соединении опознают друг друга по специальным шестибайтовым идентификаторам, mac-адресам. При настройке сети сетевые адаптеры должны знать, кто из них отвечает за какой сетевой адрес (ip-адрес), чтобы отправлять пакеты (блоки данных, передаваемые в пакетном режиме) по назначению. Для автоматического построения таблиц соответствия ip- и mac-адресов используется протокол ARP (Address Resolution Protocol).

В соединениях “точка-точка” ARP не нужен. Зато часто применяется протокол PPP (Point to Point Protocol). Кроме структуры кадра и контроля его целостности, он содержит правила для установления соединения, проверки состояния линии связи и аутентификации участников.

#Сетевой уровень 
Следующий уровень — сетевой уровень модели osi. Он предназначен для построения крупных составных сетей на основе различных сетевых технологий. На этом уровне обеспечивается согласование различий в разных технологиях канального уровня и общая адресация с помощью глобальных адресов, позволяющих однозначно определить компьютер в сети. Также выполняется маршрутизация — определение маршрута пересылки пакетов через промежуточные узлы. 

Иногда можно столкнуться с утверждением, что в Интернете в роли этого уровня выступает протокол IP (Internet Protocol). С одной стороны это так: именно IP определяет структуру отдельного пакета, передающегося по сети через шлюзы, систему сетевых адресов и некоторые другие функции. С другой стороны существует несколько других протоколов, которые также можно отнести к сетевому уровню, хотя они и работают “поверх” IP. 

Наиболее важным среди них можно считать протокол ICMP (Internet Control Message Protocol). Благодаря ему участники соединений обмениваются сообщениями о всяких штатных и нештатных ситуациях: обрыв соединения, отсутствие подходящего маршрута и другие случаи невозможности доставки пакета. Иногда сообщения ICMP содержат рекомендации по использованию альтернативного маршрута.

#Транспортный уровень
Пакеты, передаваемые по сети при помощи протоколов сетевого уровня, обычно ограничены в размерах. Они могут доставляться не в том порядке, в котором были отправлены, теряться, или, наоборот, дублироваться. Прикладным программам требуется более высокий уровень сервиса, обеспечивающий надежность доставки данных и простоту работы. За это как раз отвечают протоколы транспортного уровня модели osi. Они следят за доставкой пакетов, отправляя и анализируя соответствующие подтверждения, нумеруют пакеты и расставляют их в нужном порядке после получения.

Как говорилось выше, протоколы сетевого уровня не гарантируют доставку пакета. Отправленный пакет может потеряться или, наоборот, прийти в двух экземплярах, а пакеты, отправленные раньше других, могут прийти к получателю позже. Содержимое такого пакета обычно называют дейтаграммой (datagram). 

Одним из самых простых транспортных протоколов является UDP (user datagram protocol). Участники сетевого взаимодействия, работающие на одном компьютере, идентифицируются целыми числами, называемыми номерами портов (или просто портами). Протокол UDP предписывает добавлять к передаваемым через сеть данным номер порта отправителя и получателя, длину дейтаграммы и ее контрольную сумму. Все это “заворачивается” в пакет в соответствии с соглашениями протокола IP. При этом ответственность о подтверждениях, повторных отправках, о делении информации на небольшие порции и о последующем восстановлении исходной последовательности лежит на авторе программ. Поэтому UDP не защищает от возможности потери, дублирования пакета и нарушения порядка получения  обеспечивается только целостность данных внутри одной дейтаграммы.

Существует также второй вид транспортного взаимодействия — потоковое. Решение всех проблем, связанных с потерями пакетов, восстановлением данных из отдельных фрагментов берет на себя реализация транспортного протокола, которая оказывается гораздо сложнее реализации протокола дейтаграммного. Соответствующий транспортный протокол, используемый в Интернете, называется TCP (transmission control protocol). В отличие от работы с UDP, при потоковой работе необходимо установить соединение. Гарантируется, что все байты, записанные в поток, будут затем доступны для чтения на другом конце потока, причем их порядок будет сохранен; при невозможности соблюдения этой гарантии соединение окажется разорвано, о чем узнают оба партнера. Протокол TCP предусматривает целый ряд нетривиальных соглашений, к счастью, всю их реализацию берет на себя операционная система.

#Остальные уровни
Определить, какие из реально существующих протоколов относятся к оставшимся трем уровням, будет несколько сложней. После транспортного идет сеансовый уровень. По замыслу создателей оси модели, его целью является установка сеансов связи. Сюда можно включить определение очередности передачи сообщений в управлении диалогом, например в видеоконференциях, задачи одновременного доступа к некоторым критическим операциям и защиту от разрывов сетевого соединения (функция синхронизации). Проблема заключается в том, что на практике все это реализуется либо средствами протоколов прикладного уровня, либо еще более высокоуровневыми соглашениями, не входящими в модель OSI. Поэтому в реальных сетях сеансовый уровень не используется.

Следующий слой — уровень представления. Его задача заключается в предоставлении данных в виде, понятном как отправителю, так и получателю. Сюда можно включить различные форматы данных и правила их интерпретации: протоколы кодировки текста (ASCII, UTF-8, koi8r), спецификации разнообразных версий HTML\XHTML, графические форматы (JPEG, GIF, PNG), набор спецификаций MIME и прочее. На уровне представления реализуется шифрование и дешифрование. Самые популярные примеры - Transport Layer Security (TLS)/Secure Socket Layer (SSL).

С прикладным уровнем все просто. На нем организуется взаимодействие приложений, которыми пользуются конечные пользователи. Сюда входит электронная почта, “Всемирная паутина” (World Wide Web), социальные сети, видео и аудиосвязь и т.п

Плюсы и минусы 
Модель OSI была принята Международной организацией по стандартизации (ISO) в 1983 году. В то время сетевые технологии активно развивались. Пока в комитете спорили о стандартах, все постепенно переходили на стек TCP/IP, вытесняющий другие протоколы. Когда свет увидел реализацию протоколов OSI, на нее обрушился шквал критики. Их ругали за несоответствие реальным технологиям, неполную спецификацию, малый спектр возможностей по сравнению с существующими протоколами. 

Кроме того, эксперты отмечали деление на 7 уровней необоснованным. Некоторые слои практически не использовались, а одни и те же задачи решались на разных уровнях. Специалисты шутят, что модель OSI вышла семиуровневой, потому что в соответствующем комитете образовалось 7 подкомитетов и каждый предложил что-то свое. Между тем набор протоколов TCP/IP, на котором построен весь современный Интернет, разрабатывался узкой группой людей по принципу ad hoc - решение задачи здесь и сейчас. Никаких комитетов в создании TCP/IP участия не принимало. 

Однако не все так плохо. Неоспоримым преимуществом модели OSI является хорошая теоретическая проработка вопросов сетевого взаимодействия, поэтому сегодня она является эталоном для документации и обучения. Некоторые считают, что не все потеряно, и, возможно, модель найдет свое место, например в облачных вычислениях.



17) Хедеры http запросов
HTTP значит "Hypertext Transfer Protocol" (Протокол передачи гипертекста). Всемирная паутина использует этот протокол. Он был создан в начале 1990-х годов. Почти всё, что вы видите в вашем браузере, передаётся на ваш компьютер через HTTP. Например, когда вы открыли страницу этой статьи, ваш браузер отправил более 40 HTTP-запросов и получил HTTP-ответы для каждого из них.

Заголовки HTTP являются основной частью этих HTTP-запросов и ответов, и они несут информацию о браузере клиента, запрошенной странице, сервере и многом другом.

Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару имя-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. RFC 822). Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.

Все заголовки разделяются на четыре основных группы:

General Headers (рус. Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
Request Headers (рус. Заголовки запроса) — используются только в запросах клиента.
Response Headers (рус. Заголовки ответа) — только для ответов от сервера.
Entity Headers (рус. Заголовки сущности) — сопровождают каждую сущность сообщения.

Первая строка HTTP-запроса называется линией запроса и состоит из трёх частей:

"method"  указывает, какой это запрос. Наиболее распространённые методы GET, POST и HEAD.
"path" , как правило, является частью URL-адреса, который идёт после host (домена). Например, если запрос "https://net.tutsplus.com/tutorials/other/top-20-mysql-best-practices/" , часть path будет "/tutorials/other/top-20-mysql-best-practices/".
Часть "protocol" содержит "HTTP" и версию, которая обычно 1.1 в современных браузерах.

Три наиболее часто используемых метода запроса: GET, POST и HEAD
GET: получение документа
Это основной метод, используемый для извлечения html, изображений, JavaScript, CSS и т. д. С использованием этого метода запрошено большинство данных, загружаемых в ваш браузер.

POST: отправка данных на сервер
Даже если вы можете отправлять данные на сервер с помощью GET и строки запроса, во многих случаях POST будет предпочтительнее. Отправка больших объёмов данных с помощью GET нецелесообразна и имеет ограничения.

Запросы POST чаще всего отправляются веб-формами. 

HEAD: получение информации заголовка
HEAD идентичен GET, за исключением того, что сервер не возвращает содержимое HTTP-ответа. Когда вы отправляете запрос HEAD, это означает, что вас интересуют только код ответа и HTTP headers, а не сам документ.
С помощью этого метода браузер может проверить, был ли документ изменён для целей caching. Он также может проверить, существует ли документ вообще.

Например, если у вас много ссылок на веб-сайте, вы можете периодически отправлять HEAD-запросы каждой из них, чтобы проверить наличие неработающих ссылок. Это будет намного быстрее, чем при использовании GET.

Коды статуса HTTP
200 используются для успешных запросов.
300 для перенаправления.
400 используются, если возникла проблема с запросом.
500 используются, если возникла проблема с сервером.
200 OK
Как упоминалось ранее, этот код состояния отправляется в ответ на успешный запрос.

206 Partial Content
Если приложение запрашивает только диапазон запрошенного файла, возвращается код 206.

Это часто используется с менеджерами закачек, которые могут остановить и возобновить загрузку или разделить загрузку на части.

404 Not Found
Когда запрашиваемая страница или файл не найдена, сервер отправляет код ответа 404.

401 Unauthorized
Защищённые паролем веб-страницы отправляют этот код. Если вы не ввели логин правильно, вы можете увидеть следующее в вашем браузере.

403 Forbidden
Если вам не разрешен доступ к странице, этот код может быть отправлен в ваш браузер. Это часто происходит, когда вы пытаетесь открыть URL-адрес для папки, в которой нет индексной страницы. Если параметры сервера не позволяют отображать содержимое папки, вы получите ошибку 403.

302 (or 307) Moved Temporarily & 301 Moved Permanently
Эти два кода используются для перенаправления браузера. Например, когда вы используете службу сокращения URL, такую как bit.ly, именно так они перенаправляют людей, которые идут по ссылке.

302 и 301 обрабатываются браузером очень похоже, но они могут иметь различные значения для spiders поисковых систем. Например, если ваш сайт не готов для обслуживания, вы можете перенаправить его в другое место с помощью 302. Поисковая система продолжит проверку вашей страницы в будущем. Но если вы перенаправите с использованием 301, это сообщит spider, что ваш сайт переехал в это место навсегда. За более точной информацией: http://www.nettuts.com перейдите на https://net.tutsplus.com/ используя 301 код вместо 302.

500 Internal Server Error

Этот код обычно отображается при сбое веб-скрипта. Большинство скриптов CGI не выводят ошибки непосредственно в браузер, в отличие от PHP. Если есть фатальные ошибки, они просто отправят код статуса 500. И тогда программист должен искать в журналах ошибок сервера, чтобы найти сообщения об ошибках.


Заголовки HTTP в запросах HTTP

Host
HTTP-запрос отправляется на определенные IP-адреса. Но так как большинство серверов способны размещать несколько сайтов под одним IP, они должны знать, какое доменное имя ищет браузер.

1
Host: net.tutsplus.com
Это в основном имя host, включая домен и поддомен.

В PHP его можно найти, как $_SERVER['HTTP_HOST'] или $_SERVER['SERVER_NAME'].

User-Agent
1
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)
Этот заголовок может содержать несколько частей информации, таких как:

Имя и версия браузера.
Название и версия операционной системы.
Язык по умолчанию.
Именно так веб-сайты могут собирать определённую общую информацию о своих системах surfers. Например, они могут определить, использует ли surfer  мобильный браузер и перенаправляет их на мобильную версию своего веб-сайта, который лучше работает с низким разрешением.

В PHP может быть выражен так: $_SERVER['HTTP_USER_AGENT'].

1
2
3
if ( strstr($_SERVER['HTTP_USER_AGENT'],'MSIE 6') ) {<font></font>
  echo "Please stop using IE6!";<font></font>
}
Accept-Language
1
Accept-Language: en-us,en;q=0.5
Этот заголовок отображает настройки языка по умолчанию.   Если сайт имеет разные языковые версии, он может перенаправить нового surfer на основе этих данных.

Он может содержать несколько языков, разделённых запятыми. Первый - это предпочтительный язык, и каждый из перечисленных языков может иметь значение «q», которое представляет собой оценку предпочтения пользователя для языка (min. 0 max. 1).

В PHP его можно найти так: $ _SERVER ["HTTP_ACCEPT_LANGUAGE"].

1
2
3
if (substr($_SERVER['HTTP_ACCEPT_LANGUAGE'], 0, 2) == 'fr') {<font></font>
    header('Location: http://french.mydomain.com');<font></font>
}
Accept-Encoding
1
Accept-Encoding: gzip,deflate
Большинство современных браузеров поддерживают gzip и отправляют это в header. Затем веб-сервер может отправить выходной HTML-код в сжатом формате. Это позволяет уменьшить размер до 80% для экономии пропускной способности и времени.

В PHP его можно найти так: $ _SERVER ["HTTP_ACCEPT_ENCODING"]. Однако, когда вы используете функцию обратного вызова ob_gzhandler(), она будет проверять значение автоматически, поэтому вам это не нужно.

1
2
3
// enables output buffering<font></font>
// and all output is compressed if the browser supports it<font></font>
ob_start('ob_gzhandler');
If-Modified-Since
Если веб-документ уже сохранен в кеше в браузере и вы посещаете его снова, ваш браузер может проверить, был ли документ обновлён, отправив следующее:

1
If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT
Если он не изменялся с этой даты, сервер отправляет код ответа «304 Not Modified», а содержимое - нет, и браузер загружает содержимое из cache.

В PHP его можно найти так: $ _SERVER ['HTTP_IF_MODIFIED_SINCE'].

01
02
03
04
05
06
07
08
09
10
11
12
13
14
// assume $last_modify_time was the last the output was updated<font></font>
<font></font>
// did the browser send If-Modified-Since header?<font></font>
if(isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {<font></font>
<font></font>
    // if the browser cache matches the modify time<font></font>
    if ($last_modify_time == strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {<font></font>
<font></font>
        // send a 304 header, and no content<font></font>
        header("HTTP/1.1 304 Not Modified");<font></font>
        exit;<font></font>
    }<font></font>
<font></font>
}
Существует также HTTP-заголовок Etag, который можно использовать для проверки текущего кэша. Мы поговорим об этом в ближайшее время.

Cookie
Как следует из названия, это отправляет файлы cookie, хранящиеся в вашем браузере для этого домена.

1
Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120; foo=bar
Это пары name=value, разделённые точками с запятой. Cookies могут также содержать id сеанса.

В PHP отдельные cookie-файлы могут быть доступны с помощью массива $ _COOKIE. Вы можете напрямую обращаться к переменным сеанса, используя массив $ _SESSION, и если вам нужен id сеанса, вы можете использовать функцию session_id () вместо cookie.

1
2
3
4
5
6
7
echo $_COOKIE['foo'];<font></font>
// output: bar<font></font>
echo $_COOKIE['PHPSESSID'];<font></font>
// output: r2t5uvjq435r4q7ib3vtdjq120<font></font>
session_start();<font></font>
echo session_id();<font></font>
// output: r2t5uvjq435r4q7ib3vtdjq120
Referer
Как следует из названия, этот HTTP header содержит ссылочный url.

Например, если я зашел на домашнюю страницу Nettuts + и нажал ссылку на статью, этот header будет отправлен в мой браузер:

1
Referer: https://net.tutsplus.com/
В PHP его можно найти как $ _SERVER ['HTTP_REFERER'].

01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
if (isset($_SERVER['HTTP_REFERER'])) {<font></font>
<font></font>
    $url_info = parse_url($_SERVER['HTTP_REFERER']);<font></font>
<font></font>
    // is the surfer coming from Google?<font></font>
    if ($url_info['host'] == 'www.google.com') {<font></font>
<font></font>
        parse_str($url_info['query'], $vars);<font></font>
<font></font>
        echo "You searched on Google for this keyword: ". $vars['q'];<font></font>
<font></font>
    }<font></font>
<font></font>
}<font></font>
// if the referring url was:<font></font>
// http://www.google.com/search?source=ig&hl=en&rlz=&=&q=http+headers&aq=f&oq=&aqi=g-p1g9<font></font>
// the output will be:<font></font>
// You searched on Google for this keyword: http headers
Возможно, вы заметили, что слово «referrer» написано с ошибкой, как «referer». К сожалению, он превратился в официальную спецификацию HTTP подобным образом и застрял.

Authorization
Когда веб-страница запрашивает авторизацию, браузер открывает окно входа в систему. Когда вы вводите имя пользователя и пароль в этом окне, браузер отправляет другой HTTP-запрос, но на этот раз он содержит этот header

1
Authorization: Basic bXl1c2VyOm15cGFzcw==
Данные внутри header имеют кодировку base64. Например, base64_decode ('bXl1c2VyOm15cGFzcw ==') возвратит 'myuser: mypass'

В PHP эти значения можно найти как $ _SERVER ['PHP_AUTH_USER'] и $ _SERVER ['PHP_AUTH_PW'].

Заголовки HTTP в ответах HTTP
Теперь мы рассмотрим некоторые из наиболее распространенных HTTP headers, найденных в HTTP-ответах.

В PHP вы можете установить заголовки ответа, используя функцию header(). PHP уже отправляет определённые заголовки автоматически, для загрузки содержимого и настройки файлов cookie и прочее... Вы можете увидеть headers, которые отправляются или будут отправляться с помощью функции headers_list (). Вы можете проверить, были ли уже отправлены заголовки с помощью функции headers_sent().

Cache-Control
Определение из w3.org: «Поле заголовка Cache-Control используется для указания директив, которые ДОЛЖНЫ выполняться всеми механизмами кэширования по цепочке запросов/ответов». Эти «механизмы кэширования» включают шлюзы и прокси, которые может использовать ваш интернет-провайдер.

Пример:

1
Cache-Control: max-age=3600, public
"public" означает, что ответ может быть кэширован кем угодно. "max-age" указывает, сколько секунд действителен кеш. Разрешение кэширования вашего сайта может снизить нагрузку на сервер и пропускную способность, а также увеличить время загрузки в браузере.

Кэширование также может быть предотвращено с помощью директивы "no-cache".

1
Cache-Control: no-cache

Content-Type
Этот header указывает "mime-type" документа. Затем браузер определяет, как интерпретировать содержимое на основании этого. Например, страница html (или PHP-скрипт с выходом html) может возвращать это:

1
Content-Type: text/html; charset=UTF-8
"text" - это тип, а "html" - подтип документа. Заголовок также может содержать больше информации, такой как charset.

Для gif-изображения это может быть отправлено.

1
Content-Type: image/gif
Браузер может использовать внешнее приложение или расширение браузера на основе mime-type. Например, это приведет к загрузке Adobe Reader:

1
Content-Type: application/pdf
При загрузке напрямую Apache обычно может обнаружить mime-тип документа и отправить соответствующий header. Кроме того, большинство браузеров имеют некоторую степень отказоустойчивости и автоопределение типов mime, если заголовки указаны неверно или отсутствуют.

Вы можете найти список общих типов mime here.

В PHP вы можете использовать функцию finfo_file() для определения mime-типа файла.

Content-Disposition
Этот header указывает браузеру открыть окно загрузки файла, вместо того, чтобы пытаться проанализировать содержимое. Пример:

1
Content-Disposition: attachment; filename="download.zip"
Обратите внимание, что соответствующий заголовок Content-Type также должен быть отправлен вместе с этим:

1
2
Content-Type: application/zip<font></font>
Content-Disposition: attachment; filename="download.zip"
Content-Length
Когда контент будет передаваться браузеру, сервер может указать его размер (в байтах), используя этот header.

1
Content-Length: 89123
Это особенно полезно при загрузке файлов. Именно так браузер может определить ход загрузки.
Etag
Это еще один header, который используется для кеширования. Это выглядит так:

1
Etag: "pub1259380237;gz"
Веб-сервер может отправлять этот header с каждым документом, который он обслуживает. Значение может быть основано на последней изменённой дате, размере файла или даже контрольной сумме файла. Браузер затем сохраняет это значение, так как он кэширует документ. В следующий раз, когда браузер запрашивает тот же файл, он отправляет это в HTTP-запросе:

1
If-None-Match: "pub1259380237;gz"
Если значение Etag документа совпадает с этим, сервер будет отправлять код 304 вместо 200, и никакого содержимого. Браузер будет загружать содержимое из своего кеша.
Last-Modified
Как следует из названия, этот header указывает дату последнего изменения документа в формате GMT:

1
Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT
1
2
3
$modify_time = filemtime($file);<font></font>
<font></font>
header("Last-Modified: " . gmdate("D, d M Y H:i:s", $modify_time) . " GMT");
Это предлагает браузеру другой способ для cache документа. Браузер может отправить это в HTTP-запросе:

1
If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT

Location
Этот заголовок используется для перенаправления. Если код ответа 301 или 302, сервер также должен отправить этот header. Например, когда вы перейдете на страницу http://www.nettuts.com, ваш браузер получит следующее:

1
2
3
4
HTTP/1.x 301 Moved Permanently<font></font>
...<font></font>
Location: https://net.tutsplus.com/<font></font>
...
В PHP вы можете перенаправить surfer так:

1
header('Location: https://net.tutsplus.com/');
По умолчанию, это отправит 302 код ответа. Если вы хотите вместо 301 отправить:

1
header('Location: https://net.tutsplus.com/', true, 301);
Set-Cookie
Когда веб-сайт хочет установить или обновить файл cookie в вашем браузере, он будет использовать этот header.

1
2
Set-Cookie: skin=noskin; path=/; domain=.amazon.com; expires=Sun, 29-Nov-2009 21:42:28 GMT<font></font>
Set-Cookie: session-id=120-7333518-8165026; path=/; domain=.amazon.com; expires=Sat Feb 27 08:00:00 2010 GMT
Каждый файл cookie отправляется как отдельный header. Обратите внимание, что файлы cookie, установленные с помощью JavaScript, не проходят через HTTP headers.

В PHP вы можете установить cookie-файлы, используя функцию setcookie(), а PHP отправляет соответствующие HTTP headers.

1
setcookie("TestCookie", "foobar");
Что приводит к отправке этого заголовка:

1
Set-Cookie: TestCookie=foobar
Если дата истечения срока действия не указана, cookie удаляется, когда окно браузера закрыто.

WWW-Authenticate
Сайт может отправить этот header для аутентификации пользователя через HTTP. Когда браузер увидит этот header, он откроет диалоговое окно входа в систему.

1
WWW-Authenticate: Basic realm="Restricted Area"

Content-Encoding
Этот header обычно устанавливается, когда возвращаемое содержимое сжимается.

1
Content-Encoding: gzip
В PHP, если вы используете функцию обратного вызова ob_gzhandler(), она будет автоматически установлена.




Смотреть сайт подробнее https://code.tutsplus.com/ru/tutorials/http-headers-for-dummies--net-8039





